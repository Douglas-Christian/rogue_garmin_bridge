#!/usr/bin/env python3
"""
FIT File Converter Module for Rogue to Garmin Bridge

This module handles conversion of processed workout data to Garmin FIT format.
"""

import os
import logging
import time
import traceback
from typing import Dict, List, Any, Optional, Tuple
from datetime import datetime, timedelta

from fit_tool.fit_file_builder import FitFileBuilder
from fit_tool.profile.messages.file_id_message import FileIdMessage
from fit_tool.profile.messages.device_info_message import DeviceInfoMessage
from fit_tool.profile.messages.event_message import EventMessage
from fit_tool.profile.messages.record_message import RecordMessage
from fit_tool.profile.messages.lap_message import LapMessage
from fit_tool.profile.messages.session_message import SessionMessage
from fit_tool.profile.messages.activity_message import ActivityMessage
from fit_tool.profile.profile_type import (
    FileType, Manufacturer, Sport, SubSport, 
    Event, EventType, LapTrigger, SessionTrigger
)

# Configure logging
logging.basicConfig(
    level=logging.DEBUG,  # Changed to DEBUG for more detailed logs
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)
logger = logging.getLogger('fit_converter')

# FIT timestamp constants
# NOTE: fit_tool expects timestamps in milliseconds since Unix epoch (1970-01-01)
# It applies an offset of -631065600000 ms and a scale of 0.001 internally
FIT_EPOCH_OFFSET_MS = 631065600000  # Milliseconds from Unix epoch to FIT epoch

class FITConverter:
    """
    Class for converting processed workout data to Garmin FIT format.
    """
    
    def __init__(self, output_dir: str):
        """
        Initialize the FIT converter.
        
        Args:
            output_dir: Directory to save FIT files
        """
        self.output_dir = output_dir
        
        # Create output directory if it doesn't exist
        os.makedirs(output_dir, exist_ok=True)
    
    def convert_workout(self, processed_data, user_profile=None):
        """
        Convert a processed workout to a FIT file.
        
        Args:
            processed_data: Dictionary of processed workout data
            user_profile: User profile information (optional)
            
        Returns:
            Path to the generated FIT file
        """
        try:
            # Extract data elements from processed data
            workout_type = processed_data.get('workout_type', 'bike')
            if not workout_type:
                workout_type = 'bike'  # Default to bike if not specified
            
            start_time = processed_data.get('start_time')
            total_duration = float(processed_data.get('total_duration', 0))
            total_distance = float(processed_data.get('total_distance', 0))
            total_calories = int(processed_data.get('total_calories', 0))
            avg_power = float(processed_data.get('avg_power', 0))
            max_power = float(processed_data.get('max_power', 0))
            avg_heart_rate = float(processed_data.get('avg_heart_rate', 0))
            max_heart_rate = float(processed_data.get('max_heart_rate', 0))
            avg_cadence = float(processed_data.get('avg_cadence', 0))
            max_cadence = float(processed_data.get('max_cadence', 0))
            avg_speed = float(processed_data.get('avg_speed', 0))
            max_speed = float(processed_data.get('max_speed', 0))
            normalized_power = float(processed_data.get('normalized_power', 0))
            total_strokes = int(processed_data.get('total_strokes', 0))
            
            # Get data series (timestamps and values)
            data_series = processed_data.get('data_series', {})
            
            # Ensure all required arrays exist and have valid lengths
            timestamps = data_series.get('timestamps', [])
            if not timestamps:
                logger.error("No timestamps found in data series")
                return None
                
            # Get the number of data points from timestamps
            num_data_points = len(timestamps)
            
            # Ensure all arrays are initialized with proper length
            absolute_timestamps = data_series.get('absolute_timestamps', [])
            powers = self._ensure_array_exists(data_series.get('powers', []), num_data_points)
            heart_rates = self._ensure_array_exists(data_series.get('heart_rates', []), num_data_points)
            cadences = self._ensure_array_exists(data_series.get('cadences', []), num_data_points)
            speeds = self._ensure_array_exists(data_series.get('speeds', []), num_data_points)
            distances = self._ensure_array_exists(data_series.get('distances', []), num_data_points)
            
            logger.info(f"Processing {workout_type} workout with {num_data_points} data points")
            logger.info(f"Data arrays - Powers: {len(powers)}, Cadences: {len(cadences)}, Speeds: {len(speeds)}")
            
            # Create a FIT file builder
            builder = FitFileBuilder()
            
            # Create a timestamp for FIT file based on the start time
            if start_time:
                try:
                    unix_start_timestamp_sec = int(datetime.fromisoformat(start_time).timestamp())
                except ValueError:
                    logger.warning(f"Could not parse start_time string: {start_time}")
                    unix_start_timestamp_sec = int(time.time())
            else:
                unix_start_timestamp_sec = int(time.time())
            
            # Convert Unix timestamp (seconds) to fit_tool format (milliseconds)
            unix_start_timestamp_ms = self._unix_to_fit_timestamp_ms(unix_start_timestamp_sec)
            
            # Debug output
            logger.debug(f"Start time: {start_time}")
            logger.debug(f"Unix timestamp (seconds): {unix_start_timestamp_sec}")
            logger.debug(f"Unix timestamp (milliseconds): {unix_start_timestamp_ms}")
            
            # ...existing code...
            
        except Exception as e:
            logger.error(f"Error converting workout to FIT: {str(e)}")
            logger.error(traceback.format_exc())
            return None

    def _ensure_array_exists(self, array, expected_length):
        """
        Ensure an array exists and has the expected length.
        If the array doesn't exist or has the wrong length, create a new array with zeros.
        
        Args:
            array: The array to check
            expected_length: The expected length of the array
            
        Returns:
            An array with the expected length
        """
        if not array:
            # Array doesn't exist, create a new one with zeros
            logger.warning(f"Array doesn't exist, creating empty array of length {expected_length}")
            return [0] * expected_length
            
        if len(array) < expected_length:
            # Array is too short, pad with zeros
            logger.warning(f"Array is too short (has {len(array)}, expected {expected_length}), padding with zeros")
            return array + [0] * (expected_length - len(array))
            
        if len(array) > expected_length:
            # Array is too long, truncate
            logger.warning(f"Array is too long (has {len(array)}, expected {expected_length}), truncating")
            return array[:expected_length]
            
        # Array is the correct length
        return array

# Example usage
if __name__ == "__main__":
    from datetime import datetime
    
    # Create sample processed data
    processed_data = {
        'workout_type': 'bike',
        'start_time': datetime.now(),
        'total_duration': 60,
        'total_distance': 500,
        'total_calories': 50,
        'avg_power': 150,
        'max_power': 200,
        'normalized_power': 160,
        'avg_cadence': 80,
        'max_cadence': 100,
        'avg_heart_rate': 130,
        'max_heart_rate': 150,
        'avg_speed': 25,
        'max_speed': 30,
        'data_series': {
            'timestamps': [0, 10, 20, 30, 40, 50, 60],
            'absolute_timestamps': [
                datetime.now(),
                datetime.now() + timedelta(seconds=10),
                datetime.now() + timedelta(seconds=20),
                datetime.now() + timedelta(seconds=30),
                datetime.now() + timedelta(seconds=40),
                datetime.now() + timedelta(seconds=50),
                datetime.now() + timedelta(seconds=60)
            ],
            'powers': [100, 120, 140, 160, 180, 200, 150],
            'cadences': [70, 75, 80, 85, 90, 95, 80],
            'heart_rates': [110, 120, 130, 140, 145, 150, 140],
            'speeds': [20, 22, 24, 26, 28, 30, 25],
            'distances': [0, 60, 130, 210, 300, 400, 500]
        }
    }
    
    # Create user profile
    user_profile = {
        'name': 'John Doe',
        'age': 35,
        'weight': 75.0,
        'height': 180.0,
        'gender': 'male',
        'max_heart_rate': 185,
        'resting_heart_rate': 60,
        'ftp': 250
    }
    
    # Create FIT converter
    converter = FITConverter("./fit_files")
    
    # Convert workout to FIT
    fit_file_path = converter.convert_workout(processed_data, user_profile)
    
    print(f"FIT file created: {fit_file_path}")
